#define BASIC_CUBE_SIZE_THREAD_COUNT 8

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel AirConstituentBalance
#pragma kernel AirDeltaSum

RWStructuredBuffer<float> airBuffer;
RWStructuredBuffer<float> transferabilityBuffer;
RWStructuredBuffer<float> deltas;
RWStructuredBuffer<int> neighborCount;
int numNodes;


int width;
int height;
int depth;

int IndexNum(int _x, int _y, int _z)
{
    int index = _x + (_y * width) + (_z * depth * width);
    return index;
}
//basic cube of threads
[numthreads(BASIC_CUBE_SIZE_THREAD_COUNT, BASIC_CUBE_SIZE_THREAD_COUNT, BASIC_CUBE_SIZE_THREAD_COUNT)]
void AirConstituentBalance(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 tid : SV_GroupThreadID)
{
    //3D position to 1D array index = x + (y * maxX) + (z * maxX * maxY) from http://stackoverflow.com/questions/26162501/how-do-you-flatten-a-3d-array
    int _selfX = (tid.x * 12) + gid.x;
    //int _selfX = id.x;
    int _selfY = (tid.y * 12) + gid.y;
    //int _selfY = id.y;
    int _selfZ = (tid.z * 12) + gid.z;
    //int _selfZ = id.z;
    int _selfIndex = IndexNum(_selfX, _selfY, _selfZ);
    //int _selfIndex = _selfX + (_selfY * width) + (_selfZ * depth * width);

    //declare variables for use in the for loops
    
    //balancing with only 6 neighbors, +/- x,y,z
    int x1 = clamp(_selfX - 1, 0, 96);
    int x2 = clamp(_selfX + 1, 0, 96);
    int y1 = clamp(_selfY - 1, 0, 96);
    int y2 = clamp(_selfY + 1, 0, 96);
    int z1 = clamp(_selfZ - 1, 0, 96);
    int z2 = clamp(_selfZ + 1, 0, 96);
    int indexes[6] = {
        IndexNum(x1, _selfY, _selfZ), //first neighbor-x
        IndexNum(x2, _selfY, _selfZ), //2nd neighbor +x
        IndexNum(_selfX, y1, _selfZ), //3rd neightbor -y
        IndexNum(_selfX, y2, _selfZ), //4th neight +y
        IndexNum(_selfX, _selfY, z1), //5th neighbor -z
        IndexNum(_selfX, _selfY, z2) //6th neighbor +z
    };
    [loop]
    for (int i = 0; i < 6; i++)
    {
        float difference = airBuffer[_selfIndex] - airBuffer[indexes[i]];
        difference = (transferabilityBuffer[indexes[i]] * transferabilityBuffer[_selfIndex] * difference) / 2;
        airBuffer[_selfIndex] -= difference;
        GroupMemoryBarrierWithGroupSync();
        airBuffer[indexes[i]] += difference;
    }



    //full 26 neighbor balancing, everyone touching
    /*
    [loop]
    for (int x = -1; x <= 1; x++)
    {
        [loop]
        for (int y = -1; y <= 1; y++)
        {
            [loop]
            for (int z = -1; z <= 1; z++)
            {
                float3 _min = { 0, 0, 0 };
                float3 _max = { width - 1, height - 1, depth - 1 };

                int posX = _selfX + x;
                int posZ = _selfZ + z;
                int posY = _selfY + y;

                //returns 0 if actual neighbor position is outside of overall boundaries, 1 if inside
                float3 _curPos = { posX, posZ, posY };
                float3 _check = (step(_min, _curPos) * step(_curPos, _max));
                float _availabilityMultiplier = _check.x * _check.y * _check.z;

                //clamp to within overall boundaries to avoid array index errors in airBuffer
                int _x = clamp(posX, _min.x, _max.x);
                int _y = clamp(posY, _min.y, _max.y);
                int _z = clamp(posZ, _min.z, _max.z);

                //set the index data for the "neighbor" node -- not actually the neighbor if out of bounds
                //but having an index in place avoids array errors
                int _otherIndex = _x + (_z * width) + (_y * depth * width);
                

                GroupMemoryBarrierWithGroupSync();
                //balance airBuffer value with selected neighbor node
                float difference = airBuffer[_selfIndex] - airBuffer[_otherIndex];
                difference = (_availabilityMultiplier * transferabilityBuffer[_otherIndex] * transferabilityBuffer[_selfIndex] * difference) / 2;
                float diffTwo = difference;
                airBuffer[_selfIndex] -= difference;
                //AllMemoryBarrierWithGroupSync();
                GroupMemoryBarrierWithGroupSync();
                airBuffer[_otherIndex] += diffTwo;
            }
        }
    }
    */
}

[numthreads(BASIC_CUBE_SIZE_THREAD_COUNT,BASIC_CUBE_SIZE_THREAD_COUNT,BASIC_CUBE_SIZE_THREAD_COUNT)]
void AirDeltaSum(uint3 id : SV_DispatchThreadID)
{
    int _selfIndex = id.x + (id.z * width) + (id.y * depth * width);
    
}

