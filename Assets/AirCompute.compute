#define BASIC_CUBE_SIZE_THREAD_COUNT 8

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel AirConstituentBalance
#pragma kernel AirDeltaSum

RWStructuredBuffer<float> airBuffer;
RWStructuredBuffer<float> transferabilityBuffer;
RWStructuredBuffer<float> deltas;
RWStructuredBuffer<int> neighborCount;
int numNodes;


int width;
int height;
int depth;

//basic cube of threads
[numthreads(BASIC_CUBE_SIZE_THREAD_COUNT, BASIC_CUBE_SIZE_THREAD_COUNT, BASIC_CUBE_SIZE_THREAD_COUNT)]
void AirConstituentBalance(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 tid : SV_GroupThreadID)
{
    //3D position to 1D array index = x + (y * maxX) + (z * maxX * maxY) from http://stackoverflow.com/questions/26162501/how-do-you-flatten-a-3d-array
    int _selfX = (tid.x * 12) + gid.x;
    //int _selfX = id.x;
    int _selfY = (tid.y * 12) + gid.y;
    //int _selfY = id.y;
    int _selfZ = (tid.z * 12) + gid.z;
    //int _selfZ = id.z;
    int _selfIndex = _selfX + (_selfY * width) + (_selfZ * depth * width);

    //declare variables for use in the for loops
    
    //first level
    int z = -1;
    [loop]
    for (int x = -1; x <= 1; x++)
    {
        [loop]
        for (int y = -1; y <= 1; y++)
        {
            [loop]
            for (int z = -1; z <= 1; z++)
            {
                float3 _min = { 0, 0, 0 };
                float3 _max = { width - 1, height - 1, depth - 1 };

                int posX = _selfX + x;
                int posZ = _selfZ + z;
                int posY = _selfY + y;

                //returns 0 if actual neighbor position is outside of overall boundaries, 1 if inside
                float3 _curPos = { posX, posZ, posY };
                float3 _check = (step(_min, _curPos) * step(_curPos, _max));
                float _availabilityMultiplier = _check.x * _check.y * _check.z;

                //clamp to within overall boundaries to avoid array index errors in airBuffer
                int _x = clamp(posX, _min.x, _max.x);
                int _y = clamp(posY, _min.y, _max.y);
                int _z = clamp(posZ, _min.z, _max.z);

                //set the index data for the "neighbor" node -- not actually the neighbor if out of bounds
                //but having an index in place avoids array errors
                int _otherIndex = _x + (_z * width) + (_y * depth * width);
                

                GroupMemoryBarrierWithGroupSync();
                //balance airBuffer value with selected neighbor node
                float difference = airBuffer[_selfIndex] - airBuffer[_otherIndex];
                difference = (_availabilityMultiplier * transferabilityBuffer[_otherIndex] * transferabilityBuffer[_selfIndex] * difference) / 2;
                float diffTwo = difference;
                airBuffer[_selfIndex] -= difference;
                //AllMemoryBarrierWithGroupSync();
                GroupMemoryBarrierWithGroupSync();
                airBuffer[_otherIndex] += diffTwo;
            }
        }
    }
}

[numthreads(BASIC_CUBE_SIZE_THREAD_COUNT,BASIC_CUBE_SIZE_THREAD_COUNT,BASIC_CUBE_SIZE_THREAD_COUNT)]
void AirDeltaSum(uint3 id : SV_DispatchThreadID)
{
    int _selfIndex = id.x + (id.z * width) + (id.y * depth * width);
    
}
