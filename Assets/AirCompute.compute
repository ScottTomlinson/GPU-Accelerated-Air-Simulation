#define BASIC_CUBE_SIZE_THREAD_COUNT 10

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel AirConstituentBalance

RWStructuredBuffer<float> airBuffer;
RWStructuredBuffer<float> transferabilityBuffer;


int numNodes;

int width;
int height;
int depth;

void BalanceNodes(int selfIndex, int otherIndex, float availabilityMultiplier)
{
    float difference = airBuffer[selfIndex] - airBuffer[otherIndex];
    difference = (availabilityMultiplier * transferabilityBuffer[otherIndex] * transferabilityBuffer[selfIndex] * difference) / 2;
    airBuffer[selfIndex] -= difference;
    airBuffer[otherIndex] += difference;
}

//basic cube of threads
[numthreads(BASIC_CUBE_SIZE_THREAD_COUNT, BASIC_CUBE_SIZE_THREAD_COUNT, BASIC_CUBE_SIZE_THREAD_COUNT)]
void AirConstituentBalance(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint uid : SV_GroupIndex)
{
    //3D position to 1D array index = x + (y * maxX) + (z * maxX * maxY) from http://stackoverflow.com/questions/26162501/how-do-you-flatten-a-3d-array
    int _selfIndex = id.x + (id.z * width) + (id.y * depth * width);

    //declare variables for use in the for loops
    float3 _min = { 0, 0, 0 };
    float3 _max = { width - 1, height - 1, depth - 1 };

    [loop]
    for (int x = -1; x <= 1; x++)
    {
        [loop]
        for (int y = -1; y <= 1; y++)
        {
            [loop]
            for (int z = -1; z <= 1; z++)
            {
                int posX = id.x + x;
                int posZ = id.z + z;
                int posY = id.y + y;
                //returns 0 if actual neighbor position is outside of overall boundaries, 1 if inside
                //basically a boolean check without the gpu crying
                float3 _cur = { posX, posZ, posY };
                float _availabilityMultiplier = (step(_min, _cur) * step(_cur, _max));

                //clamp to within overall boundaries to avoid array index errors in airBuffer
                int _x = clamp(posX, 0, 99);
                int _y = clamp(posY, 0, 99);
                int _z = clamp(posZ, 0, 99);

                //set the index data for the "neighbor" node -- not actually the neighbor if out of bounds
                //but having an index in place avoids array errors
                int _otherIndex = _x + (_z * width) + (_y * depth * width);

                //balance airBuffer value with selected neighbor node
                //this is causing problems where different threads are altering the same array indexes
                //causing air to be "lost" or "gained"
                BalanceNodes(_selfIndex, _otherIndex, _availabilityMultiplier);
            }
        }
    }
}
